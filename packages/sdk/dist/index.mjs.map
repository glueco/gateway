{"version":3,"sources":["../src/keys.ts","../src/errors.ts","../src/fetch.ts","../src/pairing.ts","../src/connect.ts","../src/client.ts"],"names":[],"mappings":"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","file":"index.mjs","sourcesContent":["import * as ed from \"@noble/ed25519\";\nimport { sha512 } from \"@noble/hashes/sha512\";\n\n// Configure ed25519 to use sha512\ned.etc.sha512Sync = (...m) => sha512(ed.etc.concatBytes(...m));\n\n// ============================================\n// KEY MANAGEMENT\n// ============================================\n\nexport interface KeyPair {\n  publicKey: string; // Base64 encoded\n  privateKey: string; // Base64 encoded\n}\n\n/**\n * Generate a new Ed25519 keypair.\n */\nexport async function generateKeyPair(): Promise<KeyPair> {\n  const privateKeyBytes = ed.utils.randomPrivateKey();\n  const publicKeyBytes = await ed.getPublicKeyAsync(privateKeyBytes);\n\n  return {\n    publicKey: base64Encode(publicKeyBytes),\n    privateKey: base64Encode(privateKeyBytes),\n  };\n}\n\n/**\n * Sign a message with a private key.\n */\nexport async function sign(\n  privateKeyBase64: string,\n  message: Uint8Array,\n): Promise<string> {\n  const privateKey = base64Decode(privateKeyBase64);\n  const signature = await ed.signAsync(message, privateKey);\n  return base64Encode(signature);\n}\n\n// ============================================\n// KEY STORAGE INTERFACE\n// ============================================\n\n/**\n * Interface for key storage backends.\n * Implement this to customize where keys are stored.\n */\nexport interface KeyStorage {\n  load(): Promise<KeyPair | null>;\n  save(keyPair: KeyPair): Promise<void>;\n  delete(): Promise<void>;\n}\n\n/**\n * In-memory key storage.\n * Keys are lost when the process exits.\n */\nexport class MemoryKeyStorage implements KeyStorage {\n  private keyPair: KeyPair | null = null;\n\n  async load(): Promise<KeyPair | null> {\n    return this.keyPair;\n  }\n\n  async save(keyPair: KeyPair): Promise<void> {\n    this.keyPair = keyPair;\n  }\n\n  async delete(): Promise<void> {\n    this.keyPair = null;\n  }\n}\n\n/**\n * File-based key storage.\n * Stores keys in a JSON file.\n */\nexport class FileKeyStorage implements KeyStorage {\n  constructor(private filePath: string) {}\n\n  async load(): Promise<KeyPair | null> {\n    try {\n      // Dynamic import for Node.js fs\n      const fs = await import(\"fs/promises\");\n      const content = await fs.readFile(this.filePath, \"utf-8\");\n      return JSON.parse(content) as KeyPair;\n    } catch {\n      return null;\n    }\n  }\n\n  async save(keyPair: KeyPair): Promise<void> {\n    const fs = await import(\"fs/promises\");\n    const path = await import(\"path\");\n\n    // Ensure directory exists\n    const dir = path.dirname(this.filePath);\n    await fs.mkdir(dir, { recursive: true });\n\n    // Write file with restricted permissions\n    await fs.writeFile(this.filePath, JSON.stringify(keyPair, null, 2), {\n      mode: 0o600, // Owner read/write only\n    });\n  }\n\n  async delete(): Promise<void> {\n    try {\n      const fs = await import(\"fs/promises\");\n      await fs.unlink(this.filePath);\n    } catch {\n      // Ignore if file doesn't exist\n    }\n  }\n}\n\n/**\n * Environment-based key storage.\n * Loads from environment variables, does not save.\n */\nexport class EnvKeyStorage implements KeyStorage {\n  constructor(\n    private publicKeyEnv: string = \"GATEWAY_PUBLIC_KEY\",\n    private privateKeyEnv: string = \"GATEWAY_PRIVATE_KEY\",\n  ) {}\n\n  async load(): Promise<KeyPair | null> {\n    const publicKey = process.env[this.publicKeyEnv];\n    const privateKey = process.env[this.privateKeyEnv];\n\n    if (!publicKey || !privateKey) {\n      return null;\n    }\n\n    return { publicKey, privateKey };\n  }\n\n  async save(keyPair: KeyPair): Promise<void> {\n    console.warn(\n      `EnvKeyStorage: Cannot save keys. Set ${this.publicKeyEnv} and ${this.privateKeyEnv} manually.`,\n    );\n    console.log(`Public Key: ${keyPair.publicKey}`);\n    console.log(`Private Key: ${keyPair.privateKey}`);\n  }\n\n  async delete(): Promise<void> {\n    console.warn(\n      `EnvKeyStorage: Cannot delete keys. Remove env vars manually.`,\n    );\n  }\n}\n\n// ============================================\n// BASE64 UTILITIES\n// ============================================\n\nfunction base64Encode(bytes: Uint8Array): string {\n  if (typeof Buffer !== \"undefined\") {\n    return Buffer.from(bytes).toString(\"base64\");\n  }\n  return btoa(String.fromCharCode(...bytes));\n}\n\nfunction base64Decode(str: string): Uint8Array {\n  if (typeof Buffer !== \"undefined\") {\n    return new Uint8Array(Buffer.from(str, \"base64\"));\n  }\n  return new Uint8Array(\n    atob(str)\n      .split(\"\")\n      .map((c) => c.charCodeAt(0)),\n  );\n}\n","import { GatewayErrorResponseSchema } from \"@glueco/shared\";\n\n// ============================================\n// SDK ERROR TYPES\n// Client-side error handling for gateway responses\n// ============================================\n\n/**\n * Error thrown when the gateway returns an error response.\n * Contains structured error information from the gateway.\n */\nexport class GatewayError extends Error {\n  public readonly code: string;\n  public readonly status: number;\n  public readonly requestId?: string;\n  public readonly details?: unknown;\n\n  constructor(\n    code: string,\n    message: string,\n    status: number,\n    options?: {\n      requestId?: string;\n      details?: unknown;\n    },\n  ) {\n    super(message);\n    this.name = \"GatewayError\";\n    this.code = code;\n    this.status = status;\n    this.requestId = options?.requestId;\n    this.details = options?.details;\n  }\n\n  /**\n   * Check if this error matches a specific error code.\n   */\n  is(code: string): boolean {\n    return this.code === code;\n  }\n\n  /**\n   * Convert to a plain object for logging/serialization.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      code: this.code,\n      message: this.message,\n      status: this.status,\n      ...(this.requestId && { requestId: this.requestId }),\n      ...(this.details !== undefined && { details: this.details }),\n    };\n  }\n}\n\n/**\n * Parse a gateway error response and create a GatewayError.\n * Returns null if the response doesn't match the expected schema.\n */\nexport function parseGatewayError(\n  body: unknown,\n  status: number,\n): GatewayError | null {\n  const parsed = GatewayErrorResponseSchema.safeParse(body);\n\n  if (!parsed.success) {\n    return null;\n  }\n\n  const { error } = parsed.data;\n\n  return new GatewayError(error.code, error.message, status, {\n    requestId: error.requestId,\n    details: error.details,\n  });\n}\n\n/**\n * Type guard to check if an error is a GatewayError.\n */\nexport function isGatewayError(error: unknown): error is GatewayError {\n  return error instanceof GatewayError;\n}\n","import { sha256 } from \"@noble/hashes/sha256\";\nimport {\n  buildCanonicalRequestV1,\n  getPathWithQuery,\n  POP_VERSION,\n} from \"@glueco/shared\";\nimport { sign, KeyPair } from \"./keys\";\nimport { GatewayError, parseGatewayError } from \"./errors\";\n\n// ============================================\n// GATEWAY FETCH\n// PoP-enabled fetch wrapper for runtime requests\n// ============================================\n\nexport interface GatewayFetchOptions {\n  /** App ID received after approval */\n  appId: string;\n\n  /** Gateway/proxy URL */\n  proxyUrl: string;\n\n  /** Keypair for signing */\n  keyPair: KeyPair;\n\n  /** Optional base fetch function (for testing) */\n  baseFetch?: typeof fetch;\n\n  /** Whether to throw GatewayError on error responses (default: false for compatibility) */\n  throwOnError?: boolean;\n}\n\nexport type GatewayFetch = (\n  input: RequestInfo | URL,\n  init?: RequestInit,\n) => Promise<Response>;\n\n/**\n * Create a PoP-enabled fetch function.\n *\n * This wrapper:\n * - Adds PoP headers (x-pop-v, x-app-id, x-ts, x-nonce, x-sig)\n * - Routes requests through the gateway\n * - Preserves request body and headers\n * - Includes query params in signature (v1 protocol)\n *\n * @example\n * const gatewayFetch = createGatewayFetch({\n *   appId: 'clx123...',\n *   proxyUrl: 'https://gateway.example.com',\n *   keyPair: { publicKey: '...', privateKey: '...' },\n * });\n *\n * // Use with OpenAI SDK - explicit resource in URL\n * const client = new OpenAI({\n *   apiKey: 'unused',\n *   baseURL: 'https://gateway.example.com/r/llm/groq', // Note: /r/<type>/<provider>\n *   fetch: gatewayFetch,\n * });\n */\nexport function createGatewayFetch(options: GatewayFetchOptions): GatewayFetch {\n  const { appId, proxyUrl, keyPair, baseFetch, throwOnError = false } = options;\n\n  const fetchFn = resolveFetch(baseFetch);\n\n  return async (\n    input: RequestInfo | URL,\n    init?: RequestInit,\n  ): Promise<Response> => {\n    // Parse the URL - handle relative URLs by using proxyUrl as base\n    const proxyUrlObj = new URL(proxyUrl);\n    let url: URL;\n\n    if (typeof input === \"string\") {\n      // Handle both absolute and relative URLs\n      // Relative URLs like \"/r/llm/groq/v1/chat\" will use proxyUrl as base\n      url = new URL(input, proxyUrlObj);\n    } else if (input instanceof URL) {\n      url = input;\n    } else {\n      // Request object\n      url = new URL(input.url, proxyUrlObj);\n    }\n\n    const method = init?.method || \"GET\";\n\n    // Get body bytes\n    let bodyBytes: Uint8Array;\n    if (init?.body) {\n      if (typeof init.body === \"string\") {\n        bodyBytes = new TextEncoder().encode(init.body);\n      } else if (init.body instanceof ArrayBuffer) {\n        bodyBytes = new Uint8Array(init.body);\n      } else if (init.body instanceof Uint8Array) {\n        bodyBytes = init.body;\n      } else {\n        // For other body types, convert to string\n        bodyBytes = new TextEncoder().encode(String(init.body));\n      }\n    } else {\n      bodyBytes = new Uint8Array(0);\n    }\n\n    // Generate PoP headers\n    const timestamp = Math.floor(Date.now() / 1000).toString();\n    const nonce = generateNonce();\n    const bodyHash = base64UrlEncode(sha256(bodyBytes));\n\n    // Get path with query string for canonical request\n    const pathWithQuery = getPathWithQuery(url);\n\n    // Create canonical payload using shared builder\n    const canonicalPayload = buildCanonicalRequestV1({\n      method: method.toUpperCase(),\n      pathWithQuery,\n      appId,\n      ts: timestamp,\n      nonce,\n      bodyHash,\n    });\n\n    // Sign the payload\n    const signature = await sign(\n      keyPair.privateKey,\n      new TextEncoder().encode(canonicalPayload),\n    );\n\n    // Merge headers\n    const headers = new Headers(init?.headers);\n    headers.set(\"x-pop-v\", POP_VERSION);\n    headers.set(\"x-app-id\", appId);\n    headers.set(\"x-ts\", timestamp);\n    headers.set(\"x-nonce\", nonce);\n    headers.set(\"x-sig\", signature);\n\n    // Route through proxy - construct final URL using pathname + search\n    // This ensures we always hit the proxy, regardless of input URL origin\n    const targetUrl = new URL(url.pathname + url.search, proxyUrlObj);\n\n    // Make the request\n    const response = await fetchFn(targetUrl.toString(), {\n      ...init,\n      headers,\n    });\n\n    // Optionally throw on error responses\n    if (throwOnError && !response.ok) {\n      const body = await response\n        .clone()\n        .json()\n        .catch(() => ({}));\n      const gatewayError = parseGatewayError(body, response.status);\n\n      if (gatewayError) {\n        throw gatewayError;\n      }\n\n      throw new Error(\n        `Gateway request failed: ${response.status} ${response.statusText}`,\n      );\n    }\n\n    return response;\n  };\n}\n\n/**\n * Create a gateway fetch from environment variables.\n * Expects: GATEWAY_APP_ID, GATEWAY_PROXY_URL, GATEWAY_PUBLIC_KEY, GATEWAY_PRIVATE_KEY\n */\nexport function createGatewayFetchFromEnv(\n  options?: Pick<GatewayFetchOptions, \"baseFetch\" | \"throwOnError\">,\n): GatewayFetch {\n  const appId = process.env.GATEWAY_APP_ID;\n  const proxyUrl = process.env.GATEWAY_PROXY_URL;\n  const publicKey = process.env.GATEWAY_PUBLIC_KEY;\n  const privateKey = process.env.GATEWAY_PRIVATE_KEY;\n\n  if (!appId || !proxyUrl || !publicKey || !privateKey) {\n    throw new Error(\n      \"Missing required environment variables: GATEWAY_APP_ID, GATEWAY_PROXY_URL, GATEWAY_PUBLIC_KEY, GATEWAY_PRIVATE_KEY\",\n    );\n  }\n\n  return createGatewayFetch({\n    appId,\n    proxyUrl,\n    keyPair: { publicKey, privateKey },\n    ...options,\n  });\n}\n\n// ============================================\n// FETCH RESOLUTION\n// ============================================\n\n/**\n * Resolve fetch implementation.\n * Uses provided fetch, falls back to global, or throws clear error.\n */\nexport function resolveFetch(customFetch?: typeof fetch): typeof fetch {\n  if (customFetch) {\n    return customFetch;\n  }\n\n  if (typeof globalThis.fetch !== \"undefined\") {\n    return globalThis.fetch;\n  }\n\n  if (typeof window !== \"undefined\" && typeof window.fetch !== \"undefined\") {\n    return window.fetch;\n  }\n\n  throw new Error(\n    \"No fetch implementation available. Please provide a fetch function via options or ensure global fetch is available.\",\n  );\n}\n\n// ============================================\n// UTILITIES\n// ============================================\n\nfunction generateNonce(): string {\n  const bytes = new Uint8Array(16);\n\n  if (typeof crypto !== \"undefined\" && crypto.getRandomValues) {\n    crypto.getRandomValues(bytes);\n  } else {\n    // Node.js fallback\n    const nodeCrypto = require(\"crypto\");\n    const randomBytes = nodeCrypto.randomBytes(16);\n    bytes.set(randomBytes);\n  }\n\n  return base64UrlEncode(bytes);\n}\n\nfunction base64UrlEncode(bytes: Uint8Array): string {\n  let base64: string;\n\n  if (typeof Buffer !== \"undefined\") {\n    base64 = Buffer.from(bytes).toString(\"base64\");\n  } else {\n    base64 = btoa(String.fromCharCode(...bytes));\n  }\n\n  return base64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n}\n","// ============================================\n// PAIRING STRING PARSER\n// ============================================\n\nexport interface PairingInfo {\n  proxyUrl: string;\n  connectCode: string;\n}\n\n/**\n * Parse a pairing string into its components.\n * Format: pair::<proxy_url>::<connect_code>\n *\n * @example\n * const info = parsePairingString('pair::https://my-gateway.vercel.app::abc123xyz');\n * // { proxyUrl: 'https://my-gateway.vercel.app', connectCode: 'abc123xyz' }\n */\nexport function parsePairingString(pairingString: string): PairingInfo {\n  const trimmed = pairingString.trim();\n\n  // Validate format\n  if (!trimmed.startsWith(\"pair::\")) {\n    throw new Error('Invalid pairing string: must start with \"pair::\"');\n  }\n\n  // Split by `::`\n  const parts = trimmed.split(\"::\");\n\n  if (parts.length !== 3) {\n    throw new Error(\n      \"Invalid pairing string format. Expected: pair::<proxy_url>::<connect_code>\",\n    );\n  }\n\n  const [, proxyUrl, connectCode] = parts;\n\n  // Validate proxy URL\n  try {\n    new URL(proxyUrl);\n  } catch {\n    throw new Error(`Invalid proxy URL in pairing string: ${proxyUrl}`);\n  }\n\n  // Validate connect code\n  if (!connectCode || connectCode.length < 16) {\n    throw new Error(\"Invalid connect code in pairing string\");\n  }\n\n  return {\n    proxyUrl,\n    connectCode,\n  };\n}\n\n/**\n * Create a pairing string from components.\n * Useful for testing or manual construction.\n */\nexport function createPairingString(\n  proxyUrl: string,\n  connectCode: string,\n): string {\n  return `pair::${proxyUrl}::${connectCode}`;\n}\n","import { InstallRequestSchema } from \"@glueco/shared\";\nimport { parsePairingString } from \"./pairing\";\nimport { generateKeyPair, KeyPair, KeyStorage, MemoryKeyStorage } from \"./keys\";\nimport { GatewayError, parseGatewayError } from \"./errors\";\nimport { resolveFetch } from \"./fetch\";\n\n// ============================================\n// CONNECT FLOW\n// Handles the pairing and approval process\n// ============================================\n\nexport interface ConnectOptions {\n  /** The pairing string from the gateway */\n  pairingString: string;\n\n  /** App metadata */\n  app: {\n    name: string;\n    description?: string;\n    homepage?: string;\n  };\n\n  /**\n   * Permissions to request.\n   * resourceId format: <resourceType>:<provider> (e.g., \"llm:groq\")\n   */\n  requestedPermissions: Array<{\n    resourceId: string;\n    actions: string[];\n  }>;\n\n  /** URL to redirect back to after approval */\n  redirectUri: string;\n\n  /** Key storage backend (default: memory) */\n  keyStorage?: KeyStorage;\n\n  /** Existing keypair to use (optional) */\n  keyPair?: KeyPair;\n\n  /** Custom fetch implementation (optional) */\n  fetch?: typeof fetch;\n}\n\nexport interface ConnectResult {\n  /** URL to redirect the user to for approval */\n  approvalUrl: string;\n\n  /** Session token for tracking */\n  sessionToken: string;\n\n  /** When the session expires */\n  expiresAt: Date;\n\n  /** The proxy URL for future requests */\n  proxyUrl: string;\n\n  /** The generated keypair (store securely!) */\n  keyPair: KeyPair;\n}\n\n/**\n * Initiate the connection flow.\n *\n * 1. Parses the pairing string\n * 2. Generates (or uses provided) keypair\n * 3. Calls the prepare endpoint\n * 4. Returns the approval URL\n *\n * @example\n * const result = await connect({\n *   pairingString: 'pair::https://gateway.example.com::abc123',\n *   app: { name: 'My App' },\n *   requestedPermissions: [\n *     { resourceId: 'llm:groq', actions: ['chat.completions'] }\n *   ],\n *   redirectUri: 'https://myapp.com/callback',\n * });\n *\n * // Redirect user to result.approvalUrl\n * // Save result.keyPair securely!\n */\nexport async function connect(options: ConnectOptions): Promise<ConnectResult> {\n  // Resolve fetch implementation\n  const fetchFn = resolveFetch(options.fetch);\n\n  // Parse pairing string\n  const { proxyUrl, connectCode } = parsePairingString(options.pairingString);\n\n  // Generate or use provided keypair\n  const keyPair = options.keyPair || (await generateKeyPair());\n\n  // Save to storage if provided\n  if (options.keyStorage) {\n    await options.keyStorage.save(keyPair);\n  }\n\n  // Build request payload conforming to InstallRequestSchema\n  const requestPayload = {\n    connectCode,\n    app: {\n      name: options.app.name,\n      description: options.app.description,\n      homepage: options.app.homepage,\n    },\n    publicKey: keyPair.publicKey,\n    requestedPermissions: options.requestedPermissions,\n    redirectUri: options.redirectUri,\n  };\n\n  // Validate payload against shared schema before sending\n  const validation = InstallRequestSchema.safeParse(requestPayload);\n  if (!validation.success) {\n    throw new ConnectError(\n      `Invalid connect payload: ${validation.error.errors.map((e) => `${e.path.join(\".\")}: ${e.message}`).join(\", \")}`,\n      400,\n    );\n  }\n\n  // Call prepare endpoint\n  const response = await fetchFn(`${proxyUrl}/api/connect/prepare`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(requestPayload),\n  });\n\n  if (!response.ok) {\n    const body = await response.json().catch(() => ({}));\n    const gatewayError = parseGatewayError(body, response.status);\n\n    if (gatewayError) {\n      throw gatewayError;\n    }\n\n    throw new ConnectError(\n      body.error || \"Failed to prepare connection\",\n      response.status,\n    );\n  }\n\n  const data = await response.json();\n\n  return {\n    approvalUrl: data.approvalUrl,\n    sessionToken: data.sessionToken,\n    expiresAt: new Date(data.expiresAt),\n    proxyUrl,\n    keyPair,\n  };\n}\n\n/**\n * Handle the callback after approval.\n * Call this when the user is redirected back to your app.\n *\n * @example\n * const params = new URLSearchParams(window.location.search);\n * const result = handleCallback(params);\n *\n * if (result.approved) {\n *   console.log('App ID:', result.appId);\n * }\n */\nexport function handleCallback(params: URLSearchParams): {\n  approved: boolean;\n  appId?: string;\n} {\n  const status = params.get(\"status\");\n  const appId = params.get(\"app_id\");\n\n  if (status === \"approved\" && appId) {\n    return { approved: true, appId };\n  }\n\n  return { approved: false };\n}\n\n/**\n * Error thrown during connection.\n */\nexport class ConnectError extends Error {\n  constructor(\n    message: string,\n    public statusCode: number,\n  ) {\n    super(message);\n    this.name = \"ConnectError\";\n  }\n}\n","import { parsePairingString } from \"./pairing\";\nimport { connect, handleCallback } from \"./connect\";\nimport { createGatewayFetch, GatewayFetch, resolveFetch } from \"./fetch\";\nimport {\n  generateKeyPair,\n  KeyPair,\n  KeyStorage,\n  FileKeyStorage,\n  MemoryKeyStorage,\n} from \"./keys\";\nimport { parseGatewayError } from \"./errors\";\nimport type {\n  GatewayTransport,\n  GatewayRequestOptions,\n  GatewayResponse,\n  GatewayStreamResponse,\n} from \"./transport\";\n\n// ============================================\n// GATEWAY CLIENT\n// High-level client that combines all SDK functionality\n// ============================================\n\nexport interface GatewayClientOptions {\n  /** Storage for keypair */\n  keyStorage?: KeyStorage;\n\n  /** Storage for app config (appId, proxyUrl) */\n  configStorage?: ConfigStorage;\n\n  /** Custom fetch function (for testing or custom environments) */\n  fetch?: typeof fetch;\n\n  /** Whether to throw GatewayError on error responses (default: false) */\n  throwOnError?: boolean;\n}\n\nexport interface ConfigStorage {\n  load(): Promise<GatewayConfig | null>;\n  save(config: GatewayConfig): Promise<void>;\n  delete(): Promise<void>;\n}\n\nexport interface GatewayConfig {\n  appId: string;\n  proxyUrl: string;\n}\n\n/**\n * High-level gateway client.\n * Manages keys, config, and provides a simple interface.\n *\n * @example\n * const client = new GatewayClient({\n *   keyStorage: new FileKeyStorage('./.gateway/keys.json'),\n *   configStorage: new FileConfigStorage('./.gateway/config.json'),\n * });\n *\n * // First time: connect\n * if (!await client.isConnected()) {\n *   const result = await client.connect({\n *     pairingString: 'pair::...',\n *     app: { name: 'My App' },\n *     requestedPermissions: [\n *       { resourceId: 'llm:groq', actions: ['chat.completions'] }\n *     ],\n *     redirectUri: 'https://myapp.com/callback',\n *   });\n *   // Redirect user to result.approvalUrl\n * }\n *\n * // After callback\n * await client.handleCallback(params);\n *\n * // Get fetch for use with SDKs\n * const gatewayFetch = await client.getFetch();\n *\n * // Use with OpenAI SDK - explicit resource in baseURL\n * const openai = new OpenAI({\n *   apiKey: 'unused',\n *   baseURL: `${await client.getProxyUrl()}/r/llm/groq`,\n *   fetch: gatewayFetch,\n * });\n */\nexport class GatewayClient {\n  private keyStorage: KeyStorage;\n  private configStorage: ConfigStorage;\n  private fetchFn: typeof fetch;\n  private throwOnError: boolean;\n\n  private keyPair: KeyPair | null = null;\n  private config: GatewayConfig | null = null;\n  private gatewayFetch: GatewayFetch | null = null;\n\n  constructor(options: GatewayClientOptions = {}) {\n    this.keyStorage = options.keyStorage || new MemoryKeyStorage();\n    this.configStorage = options.configStorage || new MemoryConfigStorage();\n    this.fetchFn = resolveFetch(options.fetch);\n    this.throwOnError = options.throwOnError ?? false;\n  }\n\n  /**\n   * Check if the client is connected and has valid credentials.\n   * Returns true only if we have keys AND a config with a valid appId.\n   */\n  async isConnected(): Promise<boolean> {\n    await this.loadState();\n    return !!(this.keyPair && this.config && this.config.appId);\n  }\n\n  /**\n   * Check if a connection flow is pending (connect() was called but callback not yet received).\n   * Useful for handling page refreshes during the approval flow.\n   */\n  async isPendingApproval(): Promise<boolean> {\n    await this.loadState();\n    return !!(this.keyPair && this.config && !this.config.appId);\n  }\n\n  /**\n   * Initiate the connection flow.\n   * Returns the approval URL to redirect the user to.\n   */\n  async connect(options: {\n    pairingString: string;\n    app: { name: string; description?: string; homepage?: string };\n    requestedPermissions: Array<{ resourceId: string; actions: string[] }>;\n    redirectUri: string;\n  }) {\n    const result = await connect({\n      ...options,\n      keyStorage: this.keyStorage,\n      fetch: this.fetchFn,\n    });\n\n    // Save the keypair\n    this.keyPair = result.keyPair;\n\n    // Save partial config (appId will be added after callback)\n    // IMPORTANT: Save to storage now so callback can load the proxyUrl\n    this.config = {\n      appId: \"\", // Will be set after callback\n      proxyUrl: result.proxyUrl,\n    };\n    await this.configStorage.save(this.config);\n\n    return result;\n  }\n\n  /**\n   * Handle the callback after user approval.\n   * This loads the stored config (saved during connect()) and updates it with the appId.\n   */\n  async handleCallback(params: URLSearchParams): Promise<{\n    approved: boolean;\n    appId?: string;\n  }> {\n    const result = handleCallback(params);\n\n    if (result.approved && result.appId) {\n      // Load existing state first (config was saved during connect())\n      await this.loadState();\n\n      if (!this.config) {\n        throw new Error(\n          \"No config found. Make sure connect() was called before handleCallback(). \" +\n            \"The config should have been persisted during the connect flow.\",\n        );\n      }\n\n      // Update config with the approved appId\n      this.config = {\n        ...this.config,\n        appId: result.appId,\n      };\n      await this.configStorage.save(this.config);\n\n      // Clear cached fetch so it will be recreated with the new appId\n      this.gatewayFetch = null;\n    }\n\n    return result;\n  }\n\n  /**\n   * Get the PoP-enabled fetch function.\n   * Use this with vendor SDKs.\n   */\n  async getFetch(): Promise<GatewayFetch> {\n    if (this.gatewayFetch) {\n      return this.gatewayFetch;\n    }\n\n    await this.loadState();\n\n    if (!this.keyPair || !this.config || !this.config.appId) {\n      throw new Error(\"Client not connected. Call connect() first.\");\n    }\n\n    this.gatewayFetch = createGatewayFetch({\n      appId: this.config.appId,\n      proxyUrl: this.config.proxyUrl,\n      keyPair: this.keyPair,\n      baseFetch: this.fetchFn,\n      throwOnError: this.throwOnError,\n    });\n\n    return this.gatewayFetch;\n  }\n\n  /**\n   * Get the proxy URL for configuring SDK baseURL.\n   */\n  async getProxyUrl(): Promise<string> {\n    await this.loadState();\n\n    if (!this.config || !this.config.proxyUrl) {\n      throw new Error(\"Client not connected. Call connect() first.\");\n    }\n\n    return this.config.proxyUrl;\n  }\n\n  /**\n   * Get a resource-scoped base URL.\n   * Use this with OpenAI SDK baseURL.\n   *\n   * @example\n   * const baseURL = await client.getResourceBaseUrl('llm', 'groq');\n   * // Returns: https://gateway.example.com/r/llm/groq\n   */\n  async getResourceBaseUrl(\n    resourceType: string,\n    provider: string,\n  ): Promise<string> {\n    const proxyUrl = await this.getProxyUrl();\n    return `${proxyUrl}/r/${resourceType}/${provider}`;\n  }\n\n  /**\n   * Get the app ID.\n   */\n  async getAppId(): Promise<string> {\n    await this.loadState();\n\n    if (!this.config || !this.config.appId) {\n      throw new Error(\"Client not connected. Call connect() first.\");\n    }\n\n    return this.config.appId;\n  }\n\n  /**\n   * Get a GatewayTransport instance for use with plugin clients.\n   *\n   * This is the recommended way to use typed plugin clients:\n   *\n   * @example\n   * ```ts\n   * import { gemini } from \"@glueco/plugin-llm-gemini/client\";\n   *\n   * const transport = await client.getTransport();\n   * const geminiClient = gemini(transport);\n   *\n   * const response = await geminiClient.generateContent({\n   *   model: \"gemini-1.5-flash\",\n   *   messages: [{ role: \"user\", content: \"Hello!\" }]\n   * });\n   * ```\n   */\n  async getTransport(): Promise<GatewayTransport> {\n    const fetch = await this.getFetch();\n    const proxyUrl = await this.getProxyUrl();\n\n    const transport: GatewayTransport = {\n      async request<TResponse = unknown, TPayload = unknown>(\n        resourceId: string,\n        action: string,\n        payload: TPayload,\n        options?: GatewayRequestOptions,\n      ): Promise<GatewayResponse<TResponse>> {\n        const [resourceType, provider] = resourceId.split(\":\");\n        const url = `${proxyUrl}/r/${resourceType}/${provider}/${action.replace(\".\", \"/\")}`;\n\n        const response = await fetch(url, {\n          method: options?.method ?? \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n            ...options?.headers,\n          },\n          body: JSON.stringify(payload),\n          signal: options?.signal,\n        });\n\n        // Extract headers\n        const headers: Record<string, string> = {};\n        response.headers.forEach((value, key) => {\n          headers[key] = value;\n        });\n\n        if (!response.ok) {\n          const errorBody = await response.text();\n          let parsed: unknown;\n          try {\n            parsed = JSON.parse(errorBody);\n          } catch {\n            parsed = errorBody;\n          }\n          const error = parseGatewayError(parsed, response.status);\n          throw error ?? new Error(`Gateway error: ${response.status} ${errorBody}`);\n        }\n\n        const data = (await response.json()) as TResponse;\n\n        return {\n          data,\n          status: response.status,\n          headers,\n        };\n      },\n\n      async requestStream<TPayload = unknown>(\n        resourceId: string,\n        action: string,\n        payload: TPayload,\n        options?: Omit<GatewayRequestOptions, \"stream\">,\n      ): Promise<GatewayStreamResponse> {\n        const [resourceType, provider] = resourceId.split(\":\");\n        const url = `${proxyUrl}/r/${resourceType}/${provider}/${action.replace(\".\", \"/\")}`;\n\n        // Add stream flag to payload if it's an object\n        const streamPayload =\n          typeof payload === \"object\" && payload !== null\n            ? { ...payload, stream: true }\n            : payload;\n\n        const response = await fetch(url, {\n          method: options?.method ?? \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n            Accept: \"text/event-stream\",\n            ...options?.headers,\n          },\n          body: JSON.stringify(streamPayload),\n          signal: options?.signal,\n        });\n\n        // Extract headers\n        const headers: Record<string, string> = {};\n        response.headers.forEach((value, key) => {\n          headers[key] = value;\n        });\n\n        if (!response.ok) {\n          const errorBody = await response.text();\n          let parsed: unknown;\n          try {\n            parsed = JSON.parse(errorBody);\n          } catch {\n            parsed = errorBody;\n          }\n          const error = parseGatewayError(parsed, response.status);\n          throw error ?? new Error(`Gateway error: ${response.status} ${errorBody}`);\n        }\n\n        if (!response.body) {\n          throw new Error(\"No response body for streaming request\");\n        }\n\n        return {\n          stream: response.body,\n          status: response.status,\n          headers,\n        };\n      },\n\n      getProxyUrl: () => proxyUrl,\n\n      getFetch: () => fetch,\n    };\n\n    return transport;\n  }\n\n  /**\n   * Disconnect and clear all stored credentials.\n   */\n  async disconnect(): Promise<void> {\n    await this.keyStorage.delete();\n    await this.configStorage.delete();\n    this.keyPair = null;\n    this.config = null;\n    this.gatewayFetch = null;\n  }\n\n  /**\n   * Load state from storage.\n   */\n  private async loadState(): Promise<void> {\n    if (!this.keyPair) {\n      this.keyPair = await this.keyStorage.load();\n    }\n    if (!this.config) {\n      this.config = await this.configStorage.load();\n    }\n  }\n}\n\n// ============================================\n// CONFIG STORAGE IMPLEMENTATIONS\n// ============================================\n\n/**\n * In-memory config storage.\n */\nexport class MemoryConfigStorage implements ConfigStorage {\n  private config: GatewayConfig | null = null;\n\n  async load(): Promise<GatewayConfig | null> {\n    return this.config;\n  }\n\n  async save(config: GatewayConfig): Promise<void> {\n    this.config = config;\n  }\n\n  async delete(): Promise<void> {\n    this.config = null;\n  }\n}\n\n/**\n * File-based config storage.\n */\nexport class FileConfigStorage implements ConfigStorage {\n  constructor(private filePath: string) {}\n\n  async load(): Promise<GatewayConfig | null> {\n    try {\n      const fs = await import(\"fs/promises\");\n      const content = await fs.readFile(this.filePath, \"utf-8\");\n      return JSON.parse(content) as GatewayConfig;\n    } catch {\n      return null;\n    }\n  }\n\n  async save(config: GatewayConfig): Promise<void> {\n    const fs = await import(\"fs/promises\");\n    const path = await import(\"path\");\n\n    const dir = path.dirname(this.filePath);\n    await fs.mkdir(dir, { recursive: true });\n\n    await fs.writeFile(this.filePath, JSON.stringify(config, null, 2));\n  }\n\n  async delete(): Promise<void> {\n    try {\n      const fs = await import(\"fs/promises\");\n      await fs.unlink(this.filePath);\n    } catch {\n      // Ignore if file doesn't exist\n    }\n  }\n}\n\n/**\n * Environment-based config storage.\n */\nexport class EnvConfigStorage implements ConfigStorage {\n  constructor(\n    private appIdEnv: string = \"GATEWAY_APP_ID\",\n    private proxyUrlEnv: string = \"GATEWAY_PROXY_URL\",\n  ) {}\n\n  async load(): Promise<GatewayConfig | null> {\n    const appId = process.env[this.appIdEnv];\n    const proxyUrl = process.env[this.proxyUrlEnv];\n\n    if (!appId || !proxyUrl) {\n      return null;\n    }\n\n    return { appId, proxyUrl };\n  }\n\n  async save(config: GatewayConfig): Promise<void> {\n    console.warn(\n      `EnvConfigStorage: Cannot save config. Set ${this.appIdEnv} and ${this.proxyUrlEnv} manually.`,\n    );\n    console.log(`App ID: ${config.appId}`);\n    console.log(`Proxy URL: ${config.proxyUrl}`);\n  }\n\n  async delete(): Promise<void> {\n    console.warn(\n      `EnvConfigStorage: Cannot delete config. Remove env vars manually.`,\n    );\n  }\n}\n"]}