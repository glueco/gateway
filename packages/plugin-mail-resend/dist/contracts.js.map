{"version":3,"sources":["../src/contracts.ts"],"sourcesContent":["// ============================================\n// RESEND PLUGIN CONTRACTS\n// Shared request/response schemas for proxy and client\n// ============================================\n\nimport { z } from \"zod\";\n\n// ============================================\n// REQUEST SCHEMAS\n// ============================================\n\n/**\n * Email tag for tracking/categorization\n */\nexport const EmailTagSchema = z.object({\n  name: z.string().min(1),\n  value: z.string(),\n});\n\nexport type EmailTag = z.infer<typeof EmailTagSchema>;\n\n/**\n * Attachment schema (base64 encoded content)\n */\nexport const AttachmentSchema = z.object({\n  filename: z.string().min(1),\n  content: z.string(), // Base64 encoded\n  contentType: z.string().optional(),\n});\n\nexport type Attachment = z.infer<typeof AttachmentSchema>;\n\n/**\n * Send Email Request schema\n * Matches Resend API: https://resend.com/docs/api-reference/emails/send-email\n */\nexport const SendEmailRequestSchema = z\n  .object({\n    // Required fields\n    from: z.string().email(\"Invalid 'from' email address\"),\n    to: z.union([\n      z.string().email(\"Invalid 'to' email address\"),\n      z.array(z.string().email(\"Invalid 'to' email address\")).min(1),\n    ]),\n    subject: z.string().min(1, \"Subject cannot be empty\"),\n\n    // Content - at least one required\n    text: z.string().optional(),\n    html: z.string().optional(),\n\n    // Optional recipients\n    cc: z\n      .union([\n        z.string().email(\"Invalid 'cc' email address\"),\n        z.array(z.string().email(\"Invalid 'cc' email address\")),\n      ])\n      .optional(),\n    bcc: z\n      .union([\n        z.string().email(\"Invalid 'bcc' email address\"),\n        z.array(z.string().email(\"Invalid 'bcc' email address\")),\n      ])\n      .optional(),\n\n    // Optional metadata\n    reply_to: z\n      .union([\n        z.string().email(\"Invalid 'reply_to' email address\"),\n        z.array(z.string().email(\"Invalid 'reply_to' email address\")),\n      ])\n      .optional(),\n    headers: z.record(z.string()).optional(),\n    tags: z.array(EmailTagSchema).optional(),\n\n    // Optional scheduling (ISO 8601 datetime)\n    scheduled_at: z.string().datetime().optional(),\n\n    // Optional attachments\n    attachments: z.array(AttachmentSchema).optional(),\n  })\n  .refine((data) => data.text || data.html, {\n    message: \"At least one of 'text' or 'html' must be provided\",\n    path: [\"text\"],\n  });\n\nexport type SendEmailRequest = z.infer<typeof SendEmailRequestSchema>;\n\n// ============================================\n// RESPONSE SCHEMAS\n// ============================================\n\n/**\n * Successful send response from Resend\n */\nexport const SendEmailResponseSchema = z.object({\n  id: z.string(),\n});\n\nexport type SendEmailResponse = z.infer<typeof SendEmailResponseSchema>;\n\n/**\n * Error response from Resend\n */\nexport const ResendErrorResponseSchema = z.object({\n  statusCode: z.number().optional(),\n  message: z.string(),\n  name: z.string().optional(),\n});\n\nexport type ResendErrorResponse = z.infer<typeof ResendErrorResponseSchema>;\n\n// ============================================\n// SHAPED REQUEST (Internal)\n// Normalized for execution with arrays\n// ============================================\n\nexport interface ShapedSendEmailRequest {\n  from: string;\n  to: string[];\n  subject: string;\n  text?: string;\n  html?: string;\n  cc?: string[];\n  bcc?: string[];\n  reply_to?: string[];\n  headers?: Record<string, string>;\n  tags?: EmailTag[];\n  scheduled_at?: string;\n  attachments?: Attachment[];\n}\n\n// ============================================\n// ENFORCEMENT FIELDS\n// ============================================\n\n/**\n * Enforcement fields for email validation.\n * These are extracted during validateAndShape for policy enforcement.\n */\nexport interface ResendEnforcementFields {\n  /** Domain of the 'from' address */\n  fromDomain: string;\n  /** Unique domains across all recipients */\n  toDomains: string[];\n  /** Total count of all recipients (to + cc + bcc) */\n  recipientCount: number;\n  /** Whether HTML content is present */\n  hasHtml: boolean;\n  /** Whether attachments are present */\n  hasAttachments: boolean;\n}\n\n// ============================================\n// PLUGIN CONSTANTS\n// ============================================\n\nexport const PLUGIN_ID = \"mail:resend\" as const;\nexport const RESOURCE_TYPE = \"mail\" as const;\nexport const PROVIDER = \"resend\" as const;\nexport const VERSION = \"0.1.0\";\nexport const PLUGIN_NAME = \"Resend Email\";\n\n/** Supported actions */\nexport const ACTIONS = [\"emails.send\"] as const;\nexport type ResendAction = (typeof ACTIONS)[number];\n\n/** Enforcement knobs this plugin supports */\nexport const ENFORCEMENT_SUPPORT = [\n  \"fromDomain\",\n  \"toDomains\",\n  \"recipientCount\",\n  \"hasHtml\",\n] as const;\n\n// ============================================\n// UTILITY FUNCTIONS\n// ============================================\n\n/**\n * Extract domain from email address\n */\nexport function extractDomain(email: string): string {\n  const parts = email.split(\"@\");\n  return parts[parts.length - 1]?.toLowerCase() || \"\";\n}\n\n/**\n * Normalize email field to array\n */\nexport function normalizeToArray(\n  value: string | string[] | undefined,\n): string[] {\n  if (!value) return [];\n  return Array.isArray(value) ? value : [value];\n}\n\n/**\n * Extract unique domains from email list\n */\nexport function extractUniqueDomains(emails: string[]): string[] {\n  const domains = new Set<string>();\n  for (const email of emails) {\n    domains.add(extractDomain(email));\n  }\n  return Array.from(domains).sort();\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA,iBAAkB;AASX,IAAM,iBAAiB,aAAE,OAAO;AAAA,EACrC,MAAM,aAAE,OAAO,EAAE,IAAI,CAAC;AAAA,EACtB,OAAO,aAAE,OAAO;AAClB,CAAC;AAOM,IAAM,mBAAmB,aAAE,OAAO;AAAA,EACvC,UAAU,aAAE,OAAO,EAAE,IAAI,CAAC;AAAA,EAC1B,SAAS,aAAE,OAAO;AAAA;AAAA,EAClB,aAAa,aAAE,OAAO,EAAE,SAAS;AACnC,CAAC;AAQM,IAAM,yBAAyB,aACnC,OAAO;AAAA;AAAA,EAEN,MAAM,aAAE,OAAO,EAAE,MAAM,8BAA8B;AAAA,EACrD,IAAI,aAAE,MAAM;AAAA,IACV,aAAE,OAAO,EAAE,MAAM,4BAA4B;AAAA,IAC7C,aAAE,MAAM,aAAE,OAAO,EAAE,MAAM,4BAA4B,CAAC,EAAE,IAAI,CAAC;AAAA,EAC/D,CAAC;AAAA,EACD,SAAS,aAAE,OAAO,EAAE,IAAI,GAAG,yBAAyB;AAAA;AAAA,EAGpD,MAAM,aAAE,OAAO,EAAE,SAAS;AAAA,EAC1B,MAAM,aAAE,OAAO,EAAE,SAAS;AAAA;AAAA,EAG1B,IAAI,aACD,MAAM;AAAA,IACL,aAAE,OAAO,EAAE,MAAM,4BAA4B;AAAA,IAC7C,aAAE,MAAM,aAAE,OAAO,EAAE,MAAM,4BAA4B,CAAC;AAAA,EACxD,CAAC,EACA,SAAS;AAAA,EACZ,KAAK,aACF,MAAM;AAAA,IACL,aAAE,OAAO,EAAE,MAAM,6BAA6B;AAAA,IAC9C,aAAE,MAAM,aAAE,OAAO,EAAE,MAAM,6BAA6B,CAAC;AAAA,EACzD,CAAC,EACA,SAAS;AAAA;AAAA,EAGZ,UAAU,aACP,MAAM;AAAA,IACL,aAAE,OAAO,EAAE,MAAM,kCAAkC;AAAA,IACnD,aAAE,MAAM,aAAE,OAAO,EAAE,MAAM,kCAAkC,CAAC;AAAA,EAC9D,CAAC,EACA,SAAS;AAAA,EACZ,SAAS,aAAE,OAAO,aAAE,OAAO,CAAC,EAAE,SAAS;AAAA,EACvC,MAAM,aAAE,MAAM,cAAc,EAAE,SAAS;AAAA;AAAA,EAGvC,cAAc,aAAE,OAAO,EAAE,SAAS,EAAE,SAAS;AAAA;AAAA,EAG7C,aAAa,aAAE,MAAM,gBAAgB,EAAE,SAAS;AAClD,CAAC,EACA,OAAO,CAAC,SAAS,KAAK,QAAQ,KAAK,MAAM;AAAA,EACxC,SAAS;AAAA,EACT,MAAM,CAAC,MAAM;AACf,CAAC;AAWI,IAAM,0BAA0B,aAAE,OAAO;AAAA,EAC9C,IAAI,aAAE,OAAO;AACf,CAAC;AAOM,IAAM,4BAA4B,aAAE,OAAO;AAAA,EAChD,YAAY,aAAE,OAAO,EAAE,SAAS;AAAA,EAChC,SAAS,aAAE,OAAO;AAAA,EAClB,MAAM,aAAE,OAAO,EAAE,SAAS;AAC5B,CAAC;AAiDM,IAAM,YAAY;AAClB,IAAM,gBAAgB;AACtB,IAAM,WAAW;AACjB,IAAM,UAAU;AAChB,IAAM,cAAc;AAGpB,IAAM,UAAU,CAAC,aAAa;AAI9B,IAAM,sBAAsB;AAAA,EACjC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AASO,SAAS,cAAc,OAAuB;AACnD,QAAM,QAAQ,MAAM,MAAM,GAAG;AAC7B,SAAO,MAAM,MAAM,SAAS,CAAC,GAAG,YAAY,KAAK;AACnD;AAKO,SAAS,iBACd,OACU;AACV,MAAI,CAAC,MAAO,QAAO,CAAC;AACpB,SAAO,MAAM,QAAQ,KAAK,IAAI,QAAQ,CAAC,KAAK;AAC9C;AAKO,SAAS,qBAAqB,QAA4B;AAC/D,QAAM,UAAU,oBAAI,IAAY;AAChC,aAAW,SAAS,QAAQ;AAC1B,YAAQ,IAAI,cAAc,KAAK,CAAC;AAAA,EAClC;AACA,SAAO,MAAM,KAAK,OAAO,EAAE,KAAK;AAClC;","names":[]}