// This is your Prisma schema file
// Designed for future-proof extensibility with generic resource model

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// APP & CREDENTIALS (PoP Identity)
// ============================================

model App {
  id          String   @id @default(cuid())
  name        String
  description String?
  homepage    String?
  status      AppStatus @default(ACTIVE)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  credentials    AppCredential[]
  permissions    ResourcePermission[]
  limits         AppLimit[]
  requestLogs    RequestLog[]
  installSession InstallSession?
  
  @@index([status])
}

enum AppStatus {
  PENDING   // Awaiting approval
  ACTIVE    // Approved and active
  SUSPENDED // Temporarily disabled
  REVOKED   // Permanently disabled
}

model AppCredential {
  id            String   @id @default(cuid())
  appId         String
  app           App      @relation(fields: [appId], references: [id], onDelete: Cascade)
  
  // Ed25519 public key (base64 encoded)
  publicKey     String
  
  // Credential status for key rotation support
  status        CredentialStatus @default(ACTIVE)
  
  // Metadata
  label         String?  // e.g., "primary", "backup"
  createdAt     DateTime @default(now())
  revokedAt     DateTime?
  
  @@index([appId, status])
  @@index([publicKey])
}

enum CredentialStatus {
  ACTIVE
  REVOKED
}

// ============================================
// PAIRING FLOW
// ============================================

model ConnectCode {
  id            String   @id @default(cuid())
  
  // Store only hash of the code for security
  codeHash      String   @unique
  
  // TTL: codes expire after ~10 minutes
  expiresAt     DateTime
  
  // Single-use: mark as used after consumption
  usedAt        DateTime?
  
  createdAt     DateTime @default(now())
  
  @@index([expiresAt])
}

model InstallSession {
  id            String   @id @default(cuid())
  
  // Linked app (created during prepare)
  appId         String   @unique
  app           App      @relation(fields: [appId], references: [id], onDelete: Cascade)
  
  // Session token for approval flow
  sessionToken  String   @unique
  
  // Requested permissions (stored as JSON)
  requestedPermissions Json
  
  // Redirect URL after approval
  redirectUri   String
  
  // Flow state
  status        InstallSessionStatus @default(PENDING)
  expiresAt     DateTime
  
  createdAt     DateTime @default(now())
  completedAt   DateTime?
  
  @@index([sessionToken])
  @@index([status, expiresAt])
}

enum InstallSessionStatus {
  PENDING
  APPROVED
  DENIED
  EXPIRED
}

// ============================================
// RESOURCES & PERMISSIONS (Generic Model)
// ============================================

model ResourceSecret {
  id            String   @id @default(cuid())
  
  // Resource identifier (e.g., "llm:groq", "mail:resend")
  // Format: <resourceType>:<provider>
  resourceId    String   @unique
  
  // Human-readable name
  name          String
  
  // Resource type for categorization
  resourceType  String   // "llm", "mail", "sms", "http", etc.
  
  // Encrypted secret (envelope encryption)
  encryptedKey  String   // Base64 encoded encrypted data
  keyIv         String   // Base64 encoded IV
  
  // Provider-specific config (JSON)
  config        Json?    // baseUrl, headers, etc.
  
  // Status
  status        ResourceStatus @default(ACTIVE)
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@index([resourceType])
  @@index([status])
}

enum ResourceStatus {
  ACTIVE
  DISABLED
}

model ResourcePermission {
  id            String   @id @default(cuid())
  
  appId         String
  app           App      @relation(fields: [appId], references: [id], onDelete: Cascade)
  
  // Resource and action (e.g., "llm:groq", "chat.completions")
  // resourceId format: <resourceType>:<provider>
  resourceId    String
  action        String
  
  // ============================================
  // ACCESS POLICY - Time Controls
  // ============================================
  
  // When this permission becomes valid (null = immediately)
  validFrom     DateTime?
  
  // When this permission expires (null = never)
  expiresAt     DateTime?
  
  // Time-of-day restrictions (JSON: { startHour: 9, endHour: 17, timezone: "UTC" })
  // null = allowed 24/7
  timeWindow    Json?
  
  // ============================================
  // ACCESS POLICY - Scope Constraints  
  // ============================================
  
  // Constraints specific to resource type (JSON schema)
  // LLM: { allowedModels: ["llama-3.1-8b-instant"], maxOutputTokens: 4096, allowStreaming: true }
  // Email: { allowedFromDomains: ["myapp.com"], maxRecipients: 10 }
  constraints   Json?
  
  // ============================================
  // ACCESS POLICY - Rate Limiting
  // ============================================
  
  // Inline rate limit (requests per window)
  // null = use app-level default
  rateLimitRequests   Int?
  rateLimitWindowSecs Int?
  
  // Burst allowance (short-term spike tolerance)
  // e.g., allow 10 requests in 10 seconds even if sustained is 60/min
  burstLimit          Int?
  burstWindowSecs     Int?
  
  // ============================================
  // ACCESS POLICY - Quotas
  // ============================================
  
  // Daily quota (null = unlimited)
  dailyQuota    Int?
  
  // Monthly quota (null = unlimited)
  monthlyQuota  Int?
  
  // Token budget for LLM resources (null = unlimited)
  dailyTokenBudget   Int?
  monthlyTokenBudget Int?
  
  // Permission status
  status        PermissionStatus @default(ACTIVE)
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  // Usage tracking relation
  usageRecords  PermissionUsage[]
  
  @@unique([appId, resourceId, action])
  @@index([appId, status])
  @@index([resourceId, action])
  @@index([expiresAt])
}

// Track quota usage per permission per period
model PermissionUsage {
  id            String   @id @default(cuid())
  
  permissionId  String
  permission    ResourcePermission @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  
  // Period tracking
  periodType    UsagePeriodType
  periodStart   DateTime  // Start of day/month in UTC
  
  // Usage counters
  requestCount  Int       @default(0)
  tokenCount    Int       @default(0)  // For LLM resources
  
  updatedAt     DateTime  @updatedAt
  
  @@unique([permissionId, periodType, periodStart])
  @@index([permissionId, periodType])
  @@index([periodStart])
}

enum UsagePeriodType {
  DAILY
  MONTHLY
}

enum PermissionStatus {
  ACTIVE
  REVOKED
  EXPIRED  // Auto-set when expiresAt passes
}

// ============================================
// RATE LIMITS & BUDGETS (App-level defaults)
// ============================================

model AppLimit {
  id            String   @id @default(cuid())
  
  appId         String
  app           App      @relation(fields: [appId], references: [id], onDelete: Cascade)
  
  // Limit type
  limitType     LimitType
  
  // Resource scope (null = global for app)
  resourceId    String?
  action        String?
  
  // Limit values
  maxRequests   Int      // requests per window
  windowSeconds Int      // window duration
  
  // For budgets: period tracking
  periodType    PeriodType? // DAILY, MONTHLY
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@unique([appId, limitType, resourceId, action])
  @@index([appId])
}

enum LimitType {
  RATE_LIMIT  // Fixed window rate limit
  BUDGET      // Quota over period (daily, monthly)
}

enum PeriodType {
  DAILY
  MONTHLY
}

// ============================================
// AUDIT LOGGING
// ============================================

model RequestLog {
  id            String   @id @default(cuid())
  
  appId         String?
  app           App?     @relation(fields: [appId], references: [id], onDelete: SetNull)
  
  // Request details
  resourceId    String
  action        String
  endpoint      String
  method        String
  
  // Decision
  decision      RequestDecision
  decisionReason String?
  
  // Performance
  latencyMs     Int?
  
  // Resource-specific metadata (e.g., tokens used)
  metadata      Json?    // { inputTokens: 100, outputTokens: 50 }
  
  // Timing
  timestamp     DateTime @default(now())
  
  @@index([appId, timestamp])
  @@index([resourceId, action, timestamp])
  @@index([decision, timestamp])
}

enum RequestDecision {
  ALLOWED
  DENIED_AUTH
  DENIED_PERMISSION
  DENIED_RATE_LIMIT
  DENIED_BUDGET
  DENIED_CONSTRAINT
  ERROR
}
